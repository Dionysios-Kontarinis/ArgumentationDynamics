*** GENERAL COMMENTS:
***
*** - In Maude, our expansion rules are represented by rewriting
*** rules (which use the => sign), while our simplification 
*** rules are represented by equations.
*** - When 2 or more rules can be fired, we search for all the 
*** possibilities (by using the "search" command when running
*** this program in Maude.)
*** - Three types of attacks ('In' or '1', 'Und' or '?', and
*** 'Out' or '0').
***
*** MORE SPECIFIC COMMENTS:
***
*** - We denote the fact that attack 'b' is set against attack
*** 'a', by asserting the Atom 'b hits a'.
*** - We denote the fact that attack 'b' is set against the
*** issue, by asserting the Atom 'b hitsArg issue'.
*** - When we try to rewrite an atom such as (a 1 *),
*** if 'b hits a', we must consider (at some point) attack b.
*** Then, the rewriting procedure ERASES the atom 'b hits a'.
*** This way, we will (conveniently) never reconsider the fact
*** that 'b hits a' in the rewritings which may follow.
*** - Meaning of the '**' sign:
*** We use ** only for an attack which we want to be Und,
*** and it helps make sure that there is always at least one
*** attack which hits it, and is itself Und.
*** Just having all the attacking attacks Out, does not make the
*** attacked attack Und (it makes it, of course, In).
***
*** CHANGES (TO CONSIDER):
***
*** - Remove the definitions of specific attacks from this file.
*** - Separate 'Sign' into 'SignOpCl' and 'SignAtt'.
*** - Create the 'Conjunct' Atom.
*** - Decide on the final version of the expansions(? attacks).
*** - Perhaps consider using * -> # and * -> btm equations...
****************************************************************

mod RP_PROCEDURE is

************* SORTS AND SUBSORTS
sorts Attack AttRmv AttAdd Argument Sign Atom Conjunct .
subsorts AttRmv AttAdd < Attack .
subsorts Atom < Conjunct .

************* CONSTANTS
ops top btm : -> Atom [ctor] .
ops + - 1 ? 0 * ** # : -> Sign [ctor] . 
--- * indicates a possibly open atom, # indicates a closed atom.
ops a : -> Attack [ctor] .
ops b : -> AttRmv [ctor] .
ops c : -> AttRmv [ctor] .
ops d : -> AttAdd [ctor] .
ops e : -> AttRmv [ctor] .
--- ops z : -> Attack [ctor] .
ops issue : -> Argument [ctor] .

************* VARIABLES
vars X Y : Attack .
vars S T : Sign .
var At : Atom .

************* OPERATORS
op ___ : Attack Sign Sign -> Atom [ctor] .
op _hits_ : Attack Attack -> Atom [ctor] .
op _hitsArg_ : Attack Argument -> Atom [ctor] .
op isNotHit_ : Attack -> Atom [ctor] .
op isNotHitArg_ : Argument -> Atom [ctor] .
op PRO_ : Argument -> Atom [ctor] .
op CON_ : Argument -> Atom [ctor] .
******* The following approach does not work:
******* op _hitsbool_ : Attack Attack -> Bool [ctor] .
******* eq b hitsbool a = true .
op _and_ : Conjunct Conjunct -> Conjunct [ctor assoc comm] .

************* EQUATIONS - SIMPLIFICATION RULES
eq (X S T) and (X S T) = (X S T) .
eq (X S **) and (X S *) = (X S *) .
eq (X S *) and (X S #) = (X S #) .
eq (X 0 S) and (X 1 T) = btm .
eq (X 0 S) and (X ? T) = btm .
eq (X ? S) and (X 1 T) = btm .
eq (X 0 *) and isNotHit(X) = btm . 
eq (X ? S) and isNotHit(X) = btm .
eq PRO(issue) and isNotHitArg(issue) = top .
eq CON(issue) and isNotHitArg(issue) = btm .
eq At and btm = btm .


*****************************************************
***ceq (X 1 *) = (X 1 #) if not (Y hits X :: Atom) .
*** eq (X 1 *) = (X 1 #) .
*****************************************************


******* The following approach does not work:
******* ceq (X 0 *) = (X 0 #) if not ('Y' hits X :: Atom) .
******* eq (X 0 *) = btm [owise] .

************* REWRITING RULES - EXPANSION RULES 
----------------------------------------------------------------
------- Expansion rules for (X 1 *) atoms (rules 1, 2 and 3).
*** RULE 1: Y is Attack or AttRmv (but is not AttAdd).
crl [expand_X1*_with_Y0*] :
(X 1 *) and (Y hits X) => (X 1 *) and (Y 0 *) if not (Y :: AttAdd) .
*** RULE 2: Y is AttRmv.
crl [expand_X1*_with_Y--0#] :
(X 1 *) and (Y hits X) => (X 1 *) and (Y - -) and (Y 0 #) if (Y :: AttRmv) .
*** RULE 3: Y is AttAdd.
crl [expand_X1*_with_Y0#] :
(X 1 *) and (Y hits X) => (X 1 *) and (Y 0 #) if (Y :: AttAdd) .
----------------------------------------------------------------
------- Expansion rules for (X 0 *) atoms (rules 4 and 5).
*** RULE 4: Y is Attack or AttRmv, but is not AttAdd.
crl [expand_X0*_with_Y1*] :
(X 0 *) and (Y hits X) => (X 0 #) and (Y 1 *) if not (Y :: AttAdd) .
*** RULE 5: Y is AttAdd.
crl [expand_X0*_with_Y++1*] :
(X 0 *) and (Y hits X) => (X 0 #) and (Y + +) and (Y 1 *) if (Y :: AttAdd) .
----------------------------------------------------------------
------- Expansion rules for (X ? **),(X ? *) atoms (rules 6-12).
*** RULE 6: Sign **, Y is Attack or AttRmv, but is not AttAdd.
crl [expand_X?**_with_Y?**] :
(X ? **) and (Y hits X) => (X ? *) and (Y ? **) if not (Y :: AttAdd) .
*** RULE 7: Sign **, Y is AttAdd.
crl [expand_X?**_with_Y++?**] :
(X ? **) and (Y hits X) => (X ? *) and (Y + +) and (Y ? **) if (Y :: AttAdd) .
*** RULE 8: Sign *, Y is Attack or AttRmv, but is not AttAdd.
crl [expand_X?*_with_Y?**] :
(X ? *) and (Y hits X) => (X ? *) and (Y ? **) if not (Y :: AttAdd) .
*** RULE 9: Sign *, Y is Attack or AttRmv, but is not AttAdd.
crl [expand_X?*_with_Y0*] :
(X ? *) and (Y hits X) => (X ? *) and (Y 0 *) if not (Y :: AttAdd) .
*** RULE 10: Sign *, Y is AttRmv.
crl [expand_X?*_with_Y--0#] :
(X ? *) and (Y hits X) => (X ? *) and (Y - -) and (Y 0 #) if (Y :: AttRmv) .
*** RULE 11: Sign *, Y is AttAdd.
crl [expand_X?*_with_Y0#] :
(X ? *) and (Y hits X) => (X ? *) and (Y 0 #) if (Y :: AttAdd) .
*** RULE 12: Sign *, Y is AttAdd.
crl [expand_X?*_with_Y?#] :
(X ? *) and (Y hits X) => (X ? *) and (Y ? #) if (Y :: AttAdd) .
----------------------------------------------------------------
------- Expansion rules for PRO, CON atoms (rules 13-19).
*** RULE 13: PRO, and Y is Attack or AttRmv, but is not AttAdd.
crl [expand_PRO_Y0*] :
PRO(issue) and (Y hitsArg issue) => PRO(issue) and (Y 0 *) if not (Y :: AttAdd) .
*** RULE 14: PRO, and Y is AttRmv.
crl [expand_PRO_Y--0#] :
PRO(issue) and (Y hitsArg issue) => PRO(issue) and (Y - -) and (Y 0 #) if (Y :: AttRmv) .
*** RULE 15: PRO, and Y is AttAdd.
crl [expand_PRO_Y0#] :
PRO(issue) and (Y hitsArg issue) => PRO(issue) and (Y 0 #) if (Y :: AttAdd) .
*** RULE 16: CON, and Y is Attack or AttRmv, but is not AttAdd.
crl [expand_CON_Y1*] :
CON(issue) and (Y hitsArg issue) => (Y 1 *) if not (Y :: AttAdd) .
*** RULE 17: CON, and Y is Attack or AttRmv, but is not AttAdd.
crl [expand_CON_Y?**] :
CON(issue) and (Y hitsArg issue) => (Y ? **) if not (Y :: AttAdd) .
*** RULE 18: CON, and Y is AttAdd.
crl [expand_CON_Y++1*] :
CON(issue) and (Y hitsArg issue) => (Y + +) and (Y 1 *) if (Y :: AttAdd) .
*** RULE 19: CON, and Y is AttAdd.
crl [expand_CON_Y++?**] :
CON(issue) and (Y hitsArg issue) => (Y + +) and (Y ? **) if (Y :: AttAdd) .
----------------------------------------------------------------
endm

*** eg.1) search PRO(issue) and (a hitsArg issue) and (b hits a) *** and (isNotHit b) =>! A:Atom .
*** eg.2) search CON(issue) and (a hitsArg issue) and (b hits a) *** and (isNotHit b) =>! A:Atom .
*** We can see details of computation: 'show path <#-OF-STATE>'.   

